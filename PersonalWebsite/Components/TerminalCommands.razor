@if (CurrentState is State.Waiting)
{
    <button id="start" type="button" aria-label="start" @onclick="Start">
        
        @if (ShowInstructions)
        {
            <div id="mobile-instructions">
                <TerminalCommand Command="Tap to start" />
            </div>
            <div id="desktop-instructions">
                <TerminalCommand Command="Click to start" />
            </div>
        }
        else
        {
            <span>> <TerminalCursor /></span>            
        }
    </button>
}
else
{
    for (int i = 0; i <= ExecutedCommandCount - 1; i++)
    {
        <TerminalCommand Command="@Commands[i]" OnAnimationComplete="OnCommandCompleted" />
    }

    @if (ShowCursor)
    {
        <div>> <TerminalCursor /></div>
    }

    @if (IsTyping)
    {
        <audio autoplay loop>
            <source src="sfx/keyboard-typing.mp3" type="audio/mpeg" />
        </audio>
    }
}

@code {

    private readonly System.Timers.Timer _timer = new()
    {
        Interval = 5_000
    };

    private State CurrentState { get; set; } = State.Waiting;

    private bool IsTyping { get; set; }
    private bool ShowCursor => HasNext() && !IsTyping;
    private bool ShowInstructions { get; set; }

    private int ExecutedCommandCount { get; set; } = 0;

    [Parameter] 
    public required string[] Commands { get; set; }

    [Parameter] 
    public EventCallback OnComplete { get; set; }

    protected override void OnInitialized()
    {
        _timer.Elapsed += TriggerInstructions;
        _timer.Start();
    }

    private void TriggerInstructions(object? o, EventArgs e)
    {
        _timer.Stop();
        _timer.Elapsed -= TriggerInstructions;
        _timer.Dispose();

        ShowInstructions = true;
        StateHasChanged();
    }

    private async Task OnCommandCompleted()
    {
        IsTyping = false;
        StateHasChanged();

        await Task.Delay(600);

        if (!HasNext())
        {
            await OnComplete.InvokeAsync();
            return;
        }

        EnterNextCommand();
    }

    private bool HasNext()
    {
        return ExecutedCommandCount < Commands.Length;
    }

    private void EnterNextCommand()
    {
        IsTyping = true;
        ExecutedCommandCount++;
    }

    private void Start()
    {
        CurrentState = State.Running;
        EnterNextCommand();
    }

    private enum State { Waiting, Running, Completed }
}
